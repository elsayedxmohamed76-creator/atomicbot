/**
 * Unit tests for backup-ipc handlers:
 * - backup-detect-local
 * - backup-restore-from-dir
 * - backup-select-folder
 * - performRestoreFromSourceDir (shared helper, tested via backup-restore-from-dir)
 */
import fs from "node:fs";
import fsp from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { dialog, ipcMain } from "electron";

import JSZip from "jszip";
import { registerBackupHandlers } from "./backup-ipc";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/** Extract a registered IPC handler by channel name from mock calls. */
function getHandler(channel: string) {
  const call = vi.mocked(ipcMain.handle).mock.calls.find((c) => c[0] === channel);
  if (!call) {
    throw new Error(`IPC handler '${channel}' not registered`);
  }
  return call[1] as (...args: unknown[]) => Promise<unknown>;
}

/** Create a temporary directory for each test. */
async function makeTempDir(prefix: string): Promise<string> {
  return fsp
    .mkdir(
      path.join(os.tmpdir(), `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2)}`),
      {
        recursive: true,
      }
    )
    .then((dir) => dir ?? "");
}

// ---------------------------------------------------------------------------
// Test suite
// ---------------------------------------------------------------------------

describe("backup-ipc handlers", () => {
  let stateDir: string;
  let mockParams: Parameters<typeof registerBackupHandlers>[0];

  beforeEach(async () => {
    vi.mocked(ipcMain.handle).mockReset();

    stateDir = await makeTempDir("backup-ipc-test-state");
    // Create a minimal stateDir with atomicbot.json so gateway can "start"
    await fsp.writeFile(
      path.join(stateDir, "atomicbot.json"),
      JSON.stringify({ agents: { defaults: { workspace: path.join(stateDir, "workspace") } } }),
      "utf-8"
    );

    mockParams = {
      stateDir,
      stopGatewayChild: vi.fn(async () => {}),
      startGateway: vi.fn(async () => {}),
      getMainWindow: () => null,
      setGatewayToken: vi.fn(),
      getGatewayToken: vi.fn(() => "test-token"),
      acceptConsent: vi.fn(async () => {}),
      getGatewayState: () => null,
      getLogsDir: () => "/tmp/logs",
      getConsentAccepted: () => true,
      userData: "/tmp/user",
      logsDir: "/tmp/logs",
      atomicbotDir: "/tmp/atomicbot",
      gogBin: "/bin/gog",
      memoBin: "/bin/memo",
      remindctlBin: "/bin/remindctl",
      obsidianCliBin: "/bin/obsidian-cli",
      ghBin: "/bin/gh",
    };

    registerBackupHandlers(mockParams);
  });

  afterEach(async () => {
    // Clean up temp dirs
    try {
      await fsp.rm(stateDir, { recursive: true, force: true });
    } catch {
      // best-effort
    }
    // Also clean up .pre-restore dirs
    try {
      await fsp.rm(`${stateDir}.pre-restore`, { recursive: true, force: true });
    } catch {
      // best-effort
    }
  });

  // ── backup-detect-local ──────────────────────────────────────────────

  describe("backup-detect-local", () => {
    it("returns found=true when ~/.atomicbot/atomicbot.json exists", async () => {
      const handler = getHandler("backup-detect-local");
      // Create fake ~/.atomicbot/atomicbot.json
      const atomicbotDir = path.join(os.homedir(), ".atomicbot");
      const configExists = fs.existsSync(path.join(atomicbotDir, "atomicbot.json"));

      const result = (await handler({})) as { found: boolean; path: string };
      expect(result.path).toBe(atomicbotDir);
      // Result depends on whether the real ~/.atomicbot exists on this machine
      expect(typeof result.found).toBe("boolean");
      expect(result.found).toBe(configExists);
    });

    it("returns a valid path string", async () => {
      const handler = getHandler("backup-detect-local");
      const result = (await handler({})) as { found: boolean; path: string };
      expect(result.path).toContain(".atomicbot");
      expect(typeof result.path).toBe("string");
    });
  });

  // ── backup-select-folder ─────────────────────────────────────────────

  describe("backup-select-folder", () => {
    it("returns cancelled when dialog is cancelled", async () => {
      vi.mocked(dialog.showOpenDialog).mockResolvedValueOnce({
        canceled: true,
        filePaths: [],
      });

      const handler = getHandler("backup-select-folder");
      const result = (await handler({})) as { ok: boolean; cancelled?: boolean };
      expect(result.ok).toBe(false);
      expect(result.cancelled).toBe(true);
    });

    it("returns error when selected folder has no atomicbot.json", async () => {
      const emptyDir = await makeTempDir("backup-ipc-test-empty");
      vi.mocked(dialog.showOpenDialog).mockResolvedValueOnce({
        canceled: false,
        filePaths: [emptyDir],
      });

      const handler = getHandler("backup-select-folder");
      const result = (await handler({})) as { ok: boolean; error?: string };
      expect(result.ok).toBe(false);
      expect(result.error).toContain("atomicbot.json");

      await fsp.rm(emptyDir, { recursive: true, force: true });
    });

    it("returns ok and path when selected folder contains atomicbot.json", async () => {
      const validDir = await makeTempDir("backup-ipc-test-valid");
      await fsp.writeFile(path.join(validDir, "atomicbot.json"), "{}", "utf-8");
      vi.mocked(dialog.showOpenDialog).mockResolvedValueOnce({
        canceled: false,
        filePaths: [validDir],
      });

      const handler = getHandler("backup-select-folder");
      const result = (await handler({})) as { ok: boolean; path?: string };
      expect(result.ok).toBe(true);
      expect(result.path).toBe(validDir);

      await fsp.rm(validDir, { recursive: true, force: true });
    });
  });

  // ── backup-restore-from-dir ──────────────────────────────────────────

  describe("backup-restore-from-dir", () => {
    it("returns error when no dirPath is provided", async () => {
      const handler = getHandler("backup-restore-from-dir");
      const result = (await handler({}, {})) as { ok: boolean; error?: string };
      expect(result.ok).toBe(false);
      expect(result.error).toContain("No directory path");
    });

    it("returns error when dirPath has no atomicbot.json", async () => {
      const emptyDir = await makeTempDir("backup-ipc-test-nojson");
      const handler = getHandler("backup-restore-from-dir");
      const result = (await handler({}, { dirPath: emptyDir })) as {
        ok: boolean;
        error?: string;
      };
      expect(result.ok).toBe(false);
      expect(result.error).toContain("atomicbot.json not found");

      await fsp.rm(emptyDir, { recursive: true, force: true });
    });

    it("restores successfully from a valid directory", async () => {
      // Create a source directory with atomicbot.json
      const sourceDir = await makeTempDir("backup-ipc-test-source");
      const sourceConfig = {
        agents: { defaults: { workspace: path.join(sourceDir, "workspace") } },
        gateway: { mode: "local", bind: "loopback" },
      };
      await fsp.writeFile(
        path.join(sourceDir, "atomicbot.json"),
        JSON.stringify(sourceConfig),
        "utf-8"
      );

      const handler = getHandler("backup-restore-from-dir");
      const result = (await handler({}, { dirPath: sourceDir })) as {
        ok: boolean;
        error?: string;
      };
      expect(result.ok).toBe(true);

      // Verify the restore sequence was executed
      expect(mockParams.stopGatewayChild).toHaveBeenCalled();
      expect(mockParams.acceptConsent).toHaveBeenCalled();
      expect(mockParams.startGateway).toHaveBeenCalled();

      // Verify the config was copied to stateDir
      const restoredConfig = await fsp.readFile(path.join(stateDir, "atomicbot.json"), "utf-8");
      expect(restoredConfig).toBeTruthy();

      await fsp.rm(sourceDir, { recursive: true, force: true });
    });

    it("returns meta from backup-meta.json when present", async () => {
      const sourceDir = await makeTempDir("backup-ipc-test-meta");
      await fsp.writeFile(
        path.join(sourceDir, "atomicbot.json"),
        JSON.stringify({ agents: { defaults: { workspace: "/old/workspace" } } }),
        "utf-8"
      );
      await fsp.writeFile(
        path.join(sourceDir, "backup-meta.json"),
        JSON.stringify({ mode: "paid", savedAt: "2026-01-01T00:00:00.000Z", appVersion: "1.0.0" }),
        "utf-8"
      );

      const handler = getHandler("backup-restore-from-dir");
      const result = (await handler({}, { dirPath: sourceDir })) as {
        ok: boolean;
        meta?: { mode?: string };
      };
      expect(result.ok).toBe(true);
      expect(result.meta?.mode).toBe("paid");

      await fsp.rm(sourceDir, { recursive: true, force: true });
    });

    it("returns empty meta when backup-meta.json is missing (old backup)", async () => {
      const sourceDir = await makeTempDir("backup-ipc-test-nometa");
      await fsp.writeFile(
        path.join(sourceDir, "atomicbot.json"),
        JSON.stringify({ agents: { defaults: { workspace: "/old/workspace" } } }),
        "utf-8"
      );

      const handler = getHandler("backup-restore-from-dir");
      const result = (await handler({}, { dirPath: sourceDir })) as {
        ok: boolean;
        meta?: { mode?: string };
      };
      expect(result.ok).toBe(true);
      expect(result.meta).toEqual({});

      await fsp.rm(sourceDir, { recursive: true, force: true });
    });

    it("calls stopGateway, acceptConsent, and startGateway in order", async () => {
      const callOrder: string[] = [];
      mockParams.stopGatewayChild = vi.fn(async () => {
        callOrder.push("stop");
      });
      mockParams.acceptConsent = vi.fn(async () => {
        callOrder.push("consent");
      });
      mockParams.startGateway = vi.fn(async () => {
        callOrder.push("start");
      });

      // Re-register handlers with updated mocks
      vi.mocked(ipcMain.handle).mockReset();
      registerBackupHandlers(mockParams);

      const sourceDir = await makeTempDir("backup-ipc-test-order");
      await fsp.writeFile(
        path.join(sourceDir, "atomicbot.json"),
        JSON.stringify({ agents: { defaults: { workspace: "/old/workspace" } } }),
        "utf-8"
      );

      const handler = getHandler("backup-restore-from-dir");
      await handler({}, { dirPath: sourceDir });

      expect(callOrder).toEqual(["stop", "consent", "start"]);

      await fsp.rm(sourceDir, { recursive: true, force: true });
    });

    it("patches restored config for desktop environment", async () => {
      const sourceDir = await makeTempDir("backup-ipc-test-patch");
      await fsp.writeFile(
        path.join(sourceDir, "atomicbot.json"),
        JSON.stringify({
          agents: { defaults: { workspace: "/old/path/workspace" } },
          gateway: { mode: "remote", bind: "0.0.0.0" },
        }),
        "utf-8"
      );

      const handler = getHandler("backup-restore-from-dir");
      await handler({}, { dirPath: sourceDir });

      const restored = JSON.parse(
        await fsp.readFile(path.join(stateDir, "atomicbot.json"), "utf-8")
      );
      // Config should be patched for desktop: local mode, loopback bind
      expect(restored.gateway.mode).toBe("local");
      expect(restored.gateway.bind).toBe("loopback");

      await fsp.rm(sourceDir, { recursive: true, force: true });
    });
  });

  // ── backup-create ───────────────────────────────────────────────────

  describe("backup-create", () => {
    it("includes backup-meta.json with the supplied mode in the ZIP", async () => {
      // Stub dialog to capture the zip buffer instead of writing to disk
      let savedBuffer: Buffer | undefined;
      vi.mocked(dialog.showSaveDialog).mockResolvedValueOnce({
        canceled: false,
        filePath: path.join(os.tmpdir(), "test-backup.zip"),
      });
      const origWriteFile = fsp.writeFile.bind(fsp);
      const writeFileSpy = vi
        .spyOn(fsp, "writeFile")
        .mockImplementation(async (filePath, data, ...rest) => {
          if (typeof filePath === "string" && filePath.endsWith(".zip") && Buffer.isBuffer(data)) {
            savedBuffer = data;
          }
          return origWriteFile(filePath, data, ...rest);
        });

      const handler = getHandler("backup-create");
      const result = (await handler({}, { mode: "paid" })) as { ok: boolean };
      expect(result.ok).toBe(true);
      expect(savedBuffer).toBeDefined();

      const zip = await JSZip.loadAsync(savedBuffer!);
      const metaFile = zip.file("backup-meta.json");
      expect(metaFile).toBeTruthy();

      const metaContent = JSON.parse(await metaFile!.async("text"));
      expect(metaContent.mode).toBe("paid");
      expect(metaContent.savedAt).toBeTruthy();

      writeFileSpy.mockRestore();
    });

    it("defaults mode to self-managed when not provided", async () => {
      let savedBuffer: Buffer | undefined;
      vi.mocked(dialog.showSaveDialog).mockResolvedValueOnce({
        canceled: false,
        filePath: path.join(os.tmpdir(), "test-backup-default.zip"),
      });
      const origWriteFile = fsp.writeFile.bind(fsp);
      const writeFileSpy = vi
        .spyOn(fsp, "writeFile")
        .mockImplementation(async (filePath, data, ...rest) => {
          if (typeof filePath === "string" && filePath.endsWith(".zip") && Buffer.isBuffer(data)) {
            savedBuffer = data;
          }
          return origWriteFile(filePath, data, ...rest);
        });

      const handler = getHandler("backup-create");
      await handler({}, {});
      expect(savedBuffer).toBeDefined();

      const zip = await JSZip.loadAsync(savedBuffer!);
      const metaFile = zip.file("backup-meta.json");
      expect(metaFile).toBeTruthy();

      const metaContent = JSON.parse(await metaFile!.async("text"));
      expect(metaContent.mode).toBe("self-managed");

      writeFileSpy.mockRestore();
    });
  });

  // ── Handler registration ─────────────────────────────────────────────

  describe("handler registration", () => {
    it("registers all 6 expected backup channels", () => {
      const channels = vi.mocked(ipcMain.handle).mock.calls.map((c) => c[0]);
      expect(channels).toContain("backup-create");
      expect(channels).toContain("backup-restore");
      expect(channels).toContain("backup-detect-local");
      expect(channels).toContain("backup-restore-from-dir");
      expect(channels).toContain("backup-select-folder");
    });
  });
});
